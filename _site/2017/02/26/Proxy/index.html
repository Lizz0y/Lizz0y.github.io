<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="永远好奇，永远敬畏">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>代理机制 - Lizz0y's Notes</title>

    <link rel="canonical" href="http://localhost:5001/2017/02/26/Proxy/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Liz Notes</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/2017-02-01-binder/pic.jpeg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/2017-02-01-binder/pic.jpeg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#Android" title="Android">Android</a>
                        
                        <a class="tag" href="/tags/#Proxy" title="Proxy">Proxy</a>
                        
                        <a class="tag" href="/tags/#Hook" title="Hook">Hook</a>
                        
                    </div>
                    <h1>代理机制</h1>
                    
                    
                    <h2 class="subheading"></h2>
                    
                    <span class="meta">Posted by Liz on February 26, 2017</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<h3 id="代理">代理</h3>

<p>最近想学习插件机制和Hook原理,决定从droidPlugin开始。以下资料多来自<a href="http://weishu.me">weishu</a>与IBM资料,附带一些自己的理解,希望可以共同学习。</p>

<h4 id="静态代理">静态代理</h4>
<p>静态代理就是实现接口,将原始接口Impl当成参数传入</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Shopping</span> <span class="o">{</span>
    <span class="n">Object</span><span class="o">[]</span> <span class="nf">doShopping</span><span class="o">(</span><span class="kt">long</span> <span class="n">money</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShoppingImpl</span> <span class="kd">implements</span> <span class="n">Shopping</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">doShopping</span><span class="o">(</span><span class="kt">long</span> <span class="n">money</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"逛淘宝 ,逛商场,买买买!!"</span><span class="o">);</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"花了%s块钱"</span><span class="o">,</span> <span class="n">money</span><span class="o">));</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="s">"鞋子"</span><span class="o">,</span> <span class="s">"衣服"</span><span class="o">,</span> <span class="s">"零食"</span> <span class="o">};</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProxyShopping</span> <span class="kd">implements</span> <span class="n">Shopping</span> <span class="o">{</span>

    <span class="n">Shopping</span> <span class="n">base</span><span class="o">;</span>

    <span class="n">ProxyShopping</span><span class="o">(</span><span class="n">Shopping</span> <span class="n">base</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">doShopping</span><span class="o">(</span><span class="kt">long</span> <span class="n">money</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 先黑点钱(修改输入参数)</span>
        <span class="kt">long</span> <span class="n">readCost</span> <span class="o">=</span> <span class="o">(</span><span class="kt">long</span><span class="o">)</span> <span class="o">(</span><span class="n">money</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">);</span>

        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"花了%s块钱"</span><span class="o">,</span> <span class="n">readCost</span><span class="o">));</span>

        <span class="c1">// 帮忙买东西</span>
        <span class="n">Object</span><span class="o">[]</span> <span class="n">things</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="na">doShopping</span><span class="o">(</span><span class="n">readCost</span><span class="o">);</span>

        <span class="c1">// 偷梁换柱(修改返回值)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">things</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">things</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">things</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="s">"被掉包的东西!!"</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">things</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">Shopping</code>是接口,<code class="highlighter-rouge">ShoppingImpl</code>是接口Impl。将<code class="highlighter-rouge">Impl</code>当成参数传入代理<code class="highlighter-rouge">ProxyShopping</code>,代理就能在真实调用前和后做一些事情,<code class="highlighter-rouge">base.doShopping</code>就是真实的调用。
<img src="/img/2017-02-26-proxy/14880782089927.jpg" alt="" /></p>

<h4 id="动态代理">动态代理</h4>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">java.lang.reflect.InvocationHandler</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.lang.reflect.Method</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.lang.reflect.Proxy</span><span class="o">;</span>  
 
<span class="c1">//抽象主题类,这里不能用abstract抽象类，一定要是interface  </span>
<span class="kd">interface</span> <span class="nc">AbstractSubject</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">();</span>  
<span class="o">}</span>  
 
<span class="c1">// 真实主题类，即被代理类  </span>
<span class="kd">class</span> <span class="nc">RealSubject</span> <span class="kd">implements</span> <span class="n">AbstractSubject</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">request</span><span class="o">()</span> <span class="o">{</span>  
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"RealSubject's request() ..."</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
 
<span class="c1">// 动态代理类，实现InvocationHandler接口  </span>
<span class="kd">class</span> <span class="nc">DynamicProxy</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>  
 
    <span class="c1">// 被代理类的实例  </span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>  
 
    <span class="c1">// 将被代理者的实例传进动态代理类的构造函数中  </span>
    <span class="kd">public</span> <span class="nf">DynamicProxy</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">this</span><span class="o">.</span><span class="na">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">;</span>  
    <span class="o">}</span>  
 
    <span class="cm">/**  
     * 覆盖InvocationHandler接口中的invoke()方法  
     *   
     * 更重要的是，动态代理模式可以使得我们在不改变原来已有的代码结构  
     * 的情况下，对原来的“真实方法”进行扩展、增强其功能，并且可以达到  
     * 控制被代理对象的行为，下面的before、after就是我们可以进行特殊  
     * 代码切入的扩展点了。  
     */</span> 
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>  
            <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>  
        <span class="cm">/*  
         * before ：doSomething();  
         */</span> 
        <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">obj</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>  
          
        <span class="cm">/*  
         * after : doSomething();  
         */</span> 
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>  
    <span class="o">}</span>  
<span class="o">}</span>  
 
<span class="c1">// 测试类  </span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  
 
        <span class="c1">// 被代理类的实例  </span>
        <span class="n">AbstractSubject</span> <span class="n">realSubject</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RealSubject</span><span class="o">();</span>  
 
        <span class="c1">// 获得被代理类的类加载器，使得JVM能够加载并找到被代理类的内部结构，以及已实现的interface  </span>
        <span class="n">ClassLoader</span> <span class="n">loader</span> <span class="o">=</span> <span class="n">realSubject</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">();</span>  
 
        <span class="c1">// 获得被代理类已实现的所有接口interface,使得动态代理类的实例  </span>
        <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span> <span class="o">=</span> <span class="n">realSubject</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getInterfaces</span><span class="o">();</span>  
 
        <span class="c1">// 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序  </span>
        <span class="n">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DynamicProxy</span><span class="o">(</span><span class="n">realSubject</span><span class="o">);</span>  
 
        <span class="cm">/*  
         * loader : 被代理类的类加载器  
         * interfaces ：被代理类已实现的所有接口，而这些是动态代理类要实现的接口列表  
         * handler ： 用被代理类的实例创建动态代理类的实例，用于真正调用处理程序  
         *   
         * return ：返回实现了被代理类所实现的所有接口的Object对象，即动态代理，需要强制转型  
         */</span> 
        <span class="c1">//获得代理的实例  </span>
        <span class="n">AbstractSubject</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">AbstractSubject</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>  
                <span class="n">loader</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">,</span> <span class="n">handler</span><span class="o">);</span>  
 
        <span class="n">proxy</span><span class="o">.</span><span class="na">request</span><span class="o">();</span>  
        <span class="c1">//打印出该代理实例的名称  </span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">());</span>  
    <span class="o">}</span>  
<span class="o">}</span> 
</code></pre>
</div>

<p>分析:
<code class="highlighter-rouge">InvocationHandler</code>最主要的方法即为<code class="highlighter-rouge">invoke()</code>,通常在该方法中实现对委托类的代理访问。
通过一个<code class="highlighter-rouge">ClassLoader</code>与一组接口<code class="highlighter-rouge">interface</code>来创建动态代理类</p>

<p>以下是重要的静态方法</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器</span>
<span class="kd">static</span> <span class="n">InvocationHandler</span> <span class="nf">getInvocationHandler</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">)</span> 

<span class="c1">// 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象</span>
<span class="kd">static</span> <span class="n">Class</span> <span class="nf">getProxyClass</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="n">Class</span><span class="o">[]</span> <span class="n">interfaces</span><span class="o">)</span> 

<span class="c1">// 方法 3：该方法用于判断指定类对象是否是一个动态代理类</span>
<span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isProxyClass</span><span class="o">(</span><span class="n">Class</span> <span class="n">cl</span><span class="o">)</span> 

<span class="c1">// 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span>
<span class="kd">static</span> <span class="n">Object</span> <span class="nf">newProxyInstance</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> <span class="n">Class</span><span class="o">[]</span> <span class="n">interfaces</span><span class="o">,</span> 
    <span class="n">InvocationHandler</span> <span class="n">h</span><span class="o">)</span>
</code></pre>
</div>

<p>实现动态代理步骤:</p>

<ul>
  <li>通过实现 InvocationHandler 接口创建自己的调用处理器；</li>
  <li>通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；</li>
  <li>通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；</li>
  <li>通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。</li>
</ul>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发</span>
<span class="c1">// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用</span>
<span class="n">InvocationHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">InvocationHandlerImpl</span><span class="o">(..);</span> 

<span class="c1">// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象</span>
<span class="n">Class</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">getProxyClass</span><span class="o">(</span><span class="n">classLoader</span><span class="o">,</span> <span class="k">new</span> <span class="n">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="n">Interface</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="o">...</span> <span class="o">});</span> 

<span class="c1">// 通过反射从生成的类对象获得构造函数对象</span>
<span class="n">Constructor</span> <span class="n">constructor</span> <span class="o">=</span> <span class="n">clazz</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="k">new</span> <span class="n">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="n">InvocationHandler</span><span class="o">.</span><span class="na">class</span> <span class="o">});</span> 

<span class="c1">// 通过构造函数对象创建动态代理类实例</span>
<span class="n">Interface</span> <span class="n">Proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">Interface</span><span class="o">)</span><span class="n">constructor</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="n">handler</span> <span class="o">});</span>
</code></pre>
</div>

<p>这个与前面的例子不大一样,是因为<code class="highlighter-rouge">newProxyInstance</code>为我们进行了封装</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code> <span class="n">AbstractSubject</span> <span class="n">proxy</span> <span class="o">=</span> <span class="o">(</span><span class="n">AbstractSubject</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span>  
                <span class="n">loader</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">,</span> <span class="n">handler</span><span class="o">);</span>  
</code></pre>
</div>

<p><img src="/img/2017-02-26-proxy/14880809556091.jpg" alt="" /></p>

<p><img src="/img/2017-02-26-proxy/14880810477854.jpg" alt="" /></p>

<ul>
  <li>上图看出代理类修饰符为final&amp;public,不能被再度继承</li>
  <li>类名格式为$ProxyN</li>
</ul>

<p>如果对同一组接口重复创建动态代理类,会返回同一个。只有当接口变了,N才会递增。</p>

<p><img src="/img/2017-02-26-proxy/14880811477639.jpg" alt="" /></p>

<p>注意点:</p>

<ul>
  <li>不能有重复的接口，以避免动态代理类代码生成时的编译错误。</li>
  <li>这些接口对于类装载器必须可见，否则类装载器将无法链接它们，将会导致类定义失败</li>
  <li>需被代理的所有非 public 的接口必须在同一个包中，否则代理类生成也会失败</li>
  <li>接口的数目不能超过 65535，这是 JVM 设定的限制。</li>
</ul>

<h5 id="原理">原理</h5>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">newProxyInstance</span><span class="o">(</span><span class="n">ClassLoader</span> <span class="n">loader</span><span class="o">,</span> 
            <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">interfaces</span><span class="o">,</span> 
            <span class="n">InvocationHandler</span> <span class="n">h</span><span class="o">)</span> 
            <span class="kd">throws</span> <span class="n">IllegalArgumentException</span> <span class="o">{</span> 
    
    <span class="c1">// 检查 h 不为空，否则抛异常</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span> 
    <span class="o">}</span> 

    <span class="c1">// 获得与制定类装载器和一组接口相关的代理类类型对象</span>
    <span class="n">Class</span> <span class="n">cl</span> <span class="o">=</span> <span class="n">getProxyClass</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">);</span> 

    <span class="c1">// 通过反射获取构造函数对象并生成代理类实例</span>
    <span class="k">try</span> <span class="o">{</span> 
        <span class="n">Constructor</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="na">getConstructor</span><span class="o">(</span><span class="n">constructorParams</span><span class="o">);</span> 
        <span class="k">return</span> <span class="o">(</span><span class="n">Object</span><span class="o">)</span> <span class="n">cons</span><span class="o">.</span><span class="na">newInstance</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="n">h</span> <span class="o">});</span> 
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NoSuchMethodException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> 
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalAccessException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> 
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InstantiationException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> 
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InvocationTargetException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">InternalError</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> 
    <span class="o">}</span> 
<span class="o">}</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">getProxyClass(loader,insterfaces)</code></p>

<ol>
  <li>安全检查</li>
</ol>

<p>检查通过后将会得到一个包含所有接口名称的字符串数组，记为 String[] interfaceNames。</p>

<ol>
  <li>映射表
    <div class="highlighter-rouge"><pre class="highlight"><code>// 映射表：用于维护类装载器对象到其对应的代理类缓存
private static Map loaderToCache = new WeakHashMap(); 
</code></pre>
    </div>
    <p>通过loader获取缓存表,它将存放键值对（接口名字列表，动态生成的代理类的类对象引用）</p>
  </li>
  <li>动态生成类</li>
</ol>

<blockquote>
  <p>动态创建代理类的类对象。首先是确定代理类所在的包，其原则如前所述，如果都为 public 接口，则包名为空字符串表示顶层包；如果所有非 public 接口都在同一个包，则包名与这些接口的包名相同；如果有多个非 public 接口且不同包，则抛异常终止代理类的生成。确定了包后，就开始生成代理类的类名，同样如前所述按格式“$ProxyN”生成。类名也确定了</p>
</blockquote>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// 动态地生成代理类的字节码数组</span>
<span class="kt">byte</span><span class="o">[]</span> <span class="n">proxyClassFile</span> <span class="o">=</span> <span class="n">ProxyGenerator</span><span class="o">.</span><span class="na">generateProxyClass</span><span class="o">(</span> <span class="n">proxyName</span><span class="o">,</span> <span class="n">interfaces</span><span class="o">);</span> 
<span class="k">try</span> <span class="o">{</span> 
    <span class="c1">// 动态地定义新生成的代理类</span>
    <span class="n">proxyClass</span> <span class="o">=</span> <span class="n">defineClass0</span><span class="o">(</span><span class="n">loader</span><span class="o">,</span> <span class="n">proxyName</span><span class="o">,</span> <span class="n">proxyClassFile</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> 
        <span class="n">proxyClassFile</span><span class="o">.</span><span class="na">length</span><span class="o">);</span> 
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassFormatError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> 
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> 
<span class="o">}</span> 
<span class="c1">// 把生成的代理类的类对象记录进 proxyClasses 表</span>
<span class="n">proxyClasses</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">proxyClass</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</code></pre>
</div>
<p>Proxy 静态方法生成动态代理类同样需要通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个 .class 文件中</p>

<ol>
  <li>更新缓存表</li>
</ol>

<h4 id="实际运行时">实际运行时</h4>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">r</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> 
    <span class="c1">// 对于原始类型参数需要进行装箱操作</span>
    <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span><span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="n">arg1</span><span class="o">),</span> <span class="k">new</span> <span class="n">Long</span><span class="o">(</span><span class="n">arg2</span><span class="o">),</span> <span class="n">arg3</span><span class="o">});</span>
</code></pre>
</div>
<p>在<code class="highlighter-rouge">invoke()</code>中,如果有调用原始方法,用<code class="highlighter-rouge">method.invoke(base,arg)</code>即可</p>

<h3 id="缺陷">缺陷</h3>
<blockquote>
  <p>动态代理始终无法摆脱仅支持 interface 代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫 Proxy。Java 的继承机制注定了这些动态代理类们无法实现对 class 的动态代理，因为Java没有多继承啊摔</p>
</blockquote>

<h3 id="实例">实例</h3>
<p>没有实例总觉得不能真正理解动态代理的精髓,当它用在插件与hook上时,才会发现动态代理有多么美妙</p>

<p>动态代理的本质:
对于一系列接口,生成一个代理类,一般把原始接口实现类通过handler传给代理类,代理类帮助原始类运行接口,自然而然可以运用在Hook上。</p>

<p><code class="highlighter-rouge">weishu</code>的<code class="highlighter-rouge">BinderHook</code>是个很好的例子。</p>

<h4 id="替换剪贴板内容">替换剪贴板内容</h4>

<p>在<code class="highlighter-rouge">ClipboardManager</code>中:</p>
<pre><code class="language-Java">static private IClipboard getService() {
        synchronized (sStaticLock) {
            if (sService != null) {
                return sService;
            }
            IBinder b = ServiceManager.getService("clipboard");
            sService = IClipboard.Stub.asInterface(b);
            return sService;
        }
    }
</code></pre>
<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IClipboard</span> <span class="kd">extends</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">IInterface</span>
<span class="o">{</span>
<span class="cm">/** Local-side IPC implementation stub class. */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Stub</span> <span class="kd">extends</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Binder</span> <span class="kd">implements</span> <span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span>
<span class="o">{</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">DESCRIPTOR</span> <span class="o">=</span> <span class="s">"android.content.IClipboard"</span><span class="o">;</span>
<span class="cm">/** Construct the stub at attach it to the interface. */</span>
<span class="kd">public</span> <span class="nf">Stub</span><span class="o">()</span>
<span class="o">{</span>
<span class="k">this</span><span class="o">.</span><span class="na">attachInterface</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">DESCRIPTOR</span><span class="o">);</span>
<span class="o">}</span>
<span class="cm">/**
 * Cast an IBinder object into an android.content.IClipboard interface,
 * generating a proxy if needed.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span> <span class="nf">asInterface</span><span class="o">(</span><span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">IBinder</span> <span class="n">obj</span><span class="o">)</span>
<span class="o">{</span>
<span class="k">if</span> <span class="o">((</span><span class="n">obj</span><span class="o">==</span><span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">IInterface</span> <span class="n">iin</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">queryLocalInterface</span><span class="o">(</span><span class="n">DESCRIPTOR</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(((</span><span class="n">iin</span><span class="o">!=</span><span class="kc">null</span><span class="o">)&amp;&amp;(</span><span class="n">iin</span> <span class="k">instanceof</span> <span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span><span class="o">)))</span> <span class="o">{</span>
<span class="k">return</span> <span class="o">((</span><span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span><span class="o">)</span><span class="n">iin</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">return</span> <span class="k">new</span> <span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">Proxy</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>
<p>所以按<code class="highlighter-rouge">weishu</code>的思路,我们要进行Hook,可以替换<code class="highlighter-rouge">asInterface</code>中的obj,实现自己的<code class="highlighter-rouge">queryLocalInterface</code>。Lucky Enough，obj是一个IBinder接口,可以使用动态代理进行替换。</p>

<p>所以我们要实现两次动态代理:
1.替换<code class="highlighter-rouge">Ibinder b</code>,在自己实现的IBinder中定义新的<code class="highlighter-rouge">queryLocalInterface</code>
2.在上述的<code class="highlighter-rouge">queryLocalInterface</code>中,返回新的<code class="highlighter-rouge">private static IClipboard sService</code></p>

<p>这里回顾一下动态代理的初衷,就是把接口实现类进行代理,在自己的类中可以完成接口的新实现。所以这里可以对IBinder代理,完成<code class="highlighter-rouge">queryLocalInterface</code>的新实现;可以对IClipboard进行代理,完成剪贴等功能的新实现。</p>

<p>这里看<code class="highlighter-rouge">IBinder b = ServiceManager.getService("clipboard");</code>
不能替换静态方法,但是在getService内部</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">IBinder</span> <span class="nf">getService</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">IBinder</span> <span class="n">service</span> <span class="o">=</span> <span class="n">sCache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">service</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">service</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="nf">getIServiceManager</span><span class="o">().</span><span class="na">getService</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"error in getService"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
</code></pre>
</div>
<p>可以看到用了一个缓存,用反射把这个缓存内容替换即可。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hookClipboardService</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

        <span class="kd">final</span> <span class="n">String</span> <span class="n">CLIPBOARD_SERVICE</span> <span class="o">=</span> <span class="s">"clipboard"</span><span class="o">;</span>

        <span class="c1">// 下面这一段的意思实际就是: ServiceManager.getService("clipboard");</span>
        <span class="c1">// 只不过 ServiceManager这个类是@hide的</span>
        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">serviceManager</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"android.os.ServiceManager"</span><span class="o">);</span>
        <span class="n">Method</span> <span class="n">getService</span> <span class="o">=</span> <span class="n">serviceManager</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"getService"</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>

        <span class="c1">// ServiceManager里面管理的原始的Clipboard Binder对象</span>
        <span class="c1">// 一般来说这是一个Binder代理对象</span>
        <span class="n">IBinder</span> <span class="n">rawBinder</span> <span class="o">=</span> <span class="o">(</span><span class="n">IBinder</span><span class="o">)</span> <span class="n">getService</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">CLIPBOARD_SERVICE</span><span class="o">);</span>

        <span class="c1">// Hook 掉这个Binder代理对象的 queryLocalInterface 方法</span>
        <span class="c1">// 然后在 queryLocalInterface 返回一个IInterface对象, hook掉我们感兴趣的方法即可.</span>
        <span class="n">IBinder</span> <span class="n">hookedBinder</span> <span class="o">=</span> <span class="o">(</span><span class="n">IBinder</span><span class="o">)</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">serviceManager</span><span class="o">.</span><span class="na">getClassLoader</span><span class="o">(),</span>
                <span class="k">new</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="o">{</span> <span class="n">IBinder</span><span class="o">.</span><span class="na">class</span> <span class="o">},</span>
                <span class="k">new</span> <span class="nf">BinderProxyHookHandler</span><span class="o">(</span><span class="n">rawBinder</span><span class="o">));</span>

        <span class="c1">// 把这个hook过的Binder代理对象放进ServiceManager的cache里面</span>
        <span class="c1">// 以后查询的时候 会优先查询缓存里面的Binder, 这样就会使用被我们修改过的Binder了</span>
        <span class="n">Field</span> <span class="n">cacheField</span> <span class="o">=</span> <span class="n">serviceManager</span><span class="o">.</span><span class="na">getDeclaredField</span><span class="o">(</span><span class="s">"sCache"</span><span class="o">);</span>
        <span class="n">cacheField</span><span class="o">.</span><span class="na">setAccessible</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">IBinder</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="o">(</span><span class="n">Map</span><span class="o">)</span> <span class="n">cacheField</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
        <span class="n">cache</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">CLIPBOARD_SERVICE</span><span class="o">,</span> <span class="n">hookedBinder</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code> Field cacheField = serviceManager.getDeclaredField("sCache");
        cacheField.setAccessible(true);
        Map&lt;String, IBinder&gt; cache = (Map) cacheField.get(null);
        cache.put(CLIPBOARD_SERVICE, hookedBinder);
</code></pre>
</div>
<p>这里在sCache中,对应剪贴板服务,返回一个新的服务(本地服务或服务代理,其实一样啦)。
再看这个代理IBinder:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinderProxyHookHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TAG</span> <span class="o">=</span> <span class="s">"BinderProxyHookHandler"</span><span class="o">;</span>

    <span class="c1">// 绝大部分情况下,这是一个BinderProxy对象</span>
    <span class="c1">// 只有当Service和我们在同一个进程的时候才是Binder本地对象</span>
    <span class="c1">// 这个基本不可能</span>
    <span class="n">IBinder</span> <span class="n">base</span><span class="o">;</span>

    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">stub</span><span class="o">;</span>

    <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">iinterface</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BinderProxyHookHandler</span><span class="o">(</span><span class="n">IBinder</span> <span class="n">base</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">stub</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"android.content.IClipboard$Stub"</span><span class="o">);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">iinterface</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"android.content.IClipboard"</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>

        <span class="k">if</span> <span class="o">(</span><span class="s">"queryLocalInterface"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>

            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"hook queryLocalInterface"</span><span class="o">);</span>

            <span class="c1">// 这里直接返回真正被Hook掉的Service接口</span>
            <span class="c1">// 这里的 queryLocalInterface 就不是原本的意思了</span>
            <span class="c1">// 我们肯定不会真的返回一个本地接口, 因为我们接管了 asInterface方法的作用</span>
            <span class="c1">// 因此必须是一个完整的 asInterface 过的 IInterface对象, 既要处理本地对象,也要处理代理对象</span>
            <span class="c1">// 这只是一个Hook点而已, 它原始的含义已经被我们重定义了; 因为我们会永远确保这个方法不返回null</span>
            <span class="c1">// 让 IClipboard.Stub.asInterface 永远走到if语句的else分支里面</span>
            <span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span>

                    <span class="c1">// asInterface 的时候会检测是否是特定类型的接口然后进行强制转换</span>
                    <span class="c1">// 因此这里的动态代理生成的类型信息的类型必须是正确的</span>

                    <span class="c1">// 这里面Hook的是一个BinderProxy对象(Binder代理) (代理Binder的queryLocalInterface正常情况下是返回null)</span>
                    <span class="c1">// 因此, 正常情况下 在asInterface里面会由于BinderProxy的queryLocalInterface返回null导致系统创建一个匿名的代理对象, 这样我们就无法控制了</span>
                    <span class="c1">// 所以我们要伪造一个对象, 瞒过这个if检测, 使得系统把这个queryLocalInterface返回的对象透传给asInterface的返回值;</span>
                    <span class="c1">// 检测有两个要求, 其一: 非空, 其二, IXXInterface类型。</span>
                    <span class="c1">// 所以, 其实返回的对象不需要是Binder对象, 我们把它当作普通的对象Hook掉就ok(拦截这个对象里面对于IXXInterface相关方法的调用)</span>
                    <span class="c1">// tks  jeremyhe_cn@qq.com</span>
                    <span class="k">new</span> <span class="n">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">iinterface</span> <span class="o">},</span>
                    <span class="k">new</span> <span class="nf">BinderHookHandler</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">stub</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"method:"</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
        <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>


</code></pre>
</div>
<p>先看invoke(),对于它的<code class="highlighter-rouge">queryLocalInterface</code>,会返回一个IClipBoard代理类。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BinderHookHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">TAG</span> <span class="o">=</span> <span class="s">"BinderHookHandler"</span><span class="o">;</span>

    <span class="c1">// 原始的Service对象 (IInterface)</span>
    <span class="n">Object</span> <span class="n">base</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">BinderHookHandler</span><span class="o">(</span><span class="n">IBinder</span> <span class="n">base</span><span class="o">,</span> <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">stubClass</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">Method</span> <span class="n">asInterfaceMethod</span> <span class="o">=</span> <span class="n">stubClass</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"asInterface"</span><span class="o">,</span> <span class="n">IBinder</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="c1">// IClipboard.Stub.asInterface(base);</span>
            <span class="k">this</span><span class="o">.</span><span class="na">base</span> <span class="o">=</span> <span class="n">asInterfaceMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">base</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="s">"hooked failed!"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@TargetApi</span><span class="o">(</span><span class="n">Build</span><span class="o">.</span><span class="na">VERSION_CODES</span><span class="o">.</span><span class="na">HONEYCOMB</span><span class="o">)</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>

        <span class="c1">// 把剪切版的内容替换为 "you are hooked"</span>
        <span class="k">if</span> <span class="o">(</span><span class="s">"getPrimaryClip"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">"hook getPrimaryClip"</span><span class="o">);</span>
            <span class="k">return</span> <span class="n">ClipData</span><span class="o">.</span><span class="na">newPlainText</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="s">"you are hooked"</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 欺骗系统,使之认为剪切版上一直有内容</span>
        <span class="k">if</span> <span class="o">(</span><span class="s">"hasPrimaryClip"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre>
</div>

<p>在代理IClipBoard类中,invoke遇到具体的service调用函数时,我们可以自由发挥,做到完美hook。</p>

<p>注意:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">this</span><span class="o">.</span><span class="na">stub</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"android.content.IClipboard$Stub"</span><span class="o">);</span>
<span class="k">this</span><span class="o">.</span><span class="na">iinterface</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"android.content.IClipboard"</span><span class="o">);</span>

<span class="n">Method</span> <span class="n">asInterfaceMethod</span> <span class="o">=</span> <span class="n">stubClass</span><span class="o">.</span><span class="na">getDeclaredMethod</span><span class="o">(</span><span class="s">"asInterface"</span><span class="o">,</span> <span class="n">IBinder</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
<span class="c1">// IClipboard.Stub.asInterface(base);</span>
<span class="k">this</span><span class="o">.</span><span class="na">base</span> <span class="o">=</span> <span class="n">asInterfaceMethod</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">base</span><span class="o">);</span>

</code></pre>
</div>
<h4 id="总结">总结</h4>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="k">return</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">proxy</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getClassLoader</span><span class="o">(),</span><span class="k">new</span> <span class="n">Class</span><span class="o">[]</span> <span class="o">{</span> <span class="k">this</span><span class="o">.</span><span class="na">iinterface</span> <span class="o">},</span>
                    <span class="k">new</span> <span class="nf">BinderHookHandler</span><span class="o">(</span><span class="n">base</span><span class="o">,</span> <span class="n">stub</span><span class="o">));</span>
</code></pre>
</div>
<p>第一个参数目前看来无所谓,随便指定个classLoader即可
第二个参数是要被代理的接口
第三个参数handler,一般传入base代理类,在内部invoke中实现对method的任意蹂躏。</p>

<p>所以在剪贴板案例中,</p>

<pre><code class="language-Java">static private IClipboard getService() {
        synchronized (sStaticLock) {
            if (sService != null) {
                return sService;
            }
            IBinder b = ServiceManager.getService("clipboard");
            sService = IClipboard.Stub.asInterface(b);
            return sService;
        }
    }
</code></pre>
<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IClipboard</span> <span class="kd">extends</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">IInterface</span>
<span class="o">{</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span> <span class="nf">asInterface</span><span class="o">(</span><span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">IBinder</span> <span class="n">obj</span><span class="o">)</span>
<span class="o">{</span>
<span class="k">if</span> <span class="o">((</span><span class="n">obj</span><span class="o">==</span><span class="kc">null</span><span class="o">))</span> <span class="o">{</span>
<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">IInterface</span> <span class="n">iin</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="na">queryLocalInterface</span><span class="o">(</span><span class="n">DESCRIPTOR</span><span class="o">);</span>
<span class="k">if</span> <span class="o">(((</span><span class="n">iin</span><span class="o">!=</span><span class="kc">null</span><span class="o">)&amp;&amp;(</span><span class="n">iin</span> <span class="k">instanceof</span> <span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span><span class="o">)))</span> <span class="o">{</span>
<span class="k">return</span> <span class="o">((</span><span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span><span class="o">)</span><span class="n">iin</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">return</span> <span class="k">new</span> <span class="n">android</span><span class="o">.</span><span class="na">content</span><span class="o">.</span><span class="na">IClipboard</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">Proxy</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
<span class="o">}</span>
</code></pre>
</div>
<p>替换了IBinder的queryLocalInterface,出现第一个动态代理;
替换了IClipboard的service函数,出现第二个动态代理</p>

<h3 id="插件activity的实现">插件Activity的实现</h3>

<p>简要分析一下Activity启动过程:</p>

<p><img src="/img/2017-02-26-proxy/14881008275563.png" alt="" /></p>

<p>从这张图可以看出,在应用进程startActivity,AMS只负责控制生命周期,做一些安全检查,最终还是回调到应用进程反射创建Activity与实现周期变化</p>

<p>插件Activity的难处在于你的Activity都要在manifest里注册,所以可以先注册一个fakeActivity，然后再通过hook实现realActivity的启动与生命周期变换。</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ActivityManagerNative</span><span class="o">.</span><span class="na">getDefault</span><span class="o">().</span><span class="na">startActivity</span><span class="o">(</span><span class="n">whoThread</span><span class="o">,</span> <span class="n">who</span><span class="o">.</span><span class="na">getBasePackageName</span><span class="o">(),</span> <span class="n">intent</span><span class="o">,</span><span class="n">intent</span><span class="o">.</span><span class="na">resolveTypeIfNeeded</span><span class="o">(</span><span class="n">who</span><span class="o">.</span><span class="na">getContentResolver</span><span class="o">()),</span><span class="n">token</span><span class="o">,</span> <span class="n">target</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">target</span><span class="o">.</span><span class="na">mEmbeddedID</span> <span class="o">:</span> <span class="kc">null</span><span class="o">,</span><span class="n">requestCode</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="n">options</span><span class="o">);</span>
                
</code></pre>
</div>

<p>可以看到,使用AMS的proxy来进行startActivity，因此把IActivityManager这个接口hook掉,即可实现realActivity-&gt;fakeActivity-&gt;ams的过程。</p>

<p>因为最终App进程的ApplicationThread通过handler与ActivityThread交互,所以通过代理重写handler,即可实现fakeActivity-&gt;create new realActivity的过程。</p>

<h3 id="未完待续">未完待续</h3>

<p>关于生命周期暂时延后,等分析完全部四大组件的sourceCode再继续。</p>



                <hr>

                
                <!-- 多说 Share start -->
                </style>
                <div class="ds-share"
                    style="text-align: right"
                    data-thread-key="/2017/02/26/Proxy"
                    data-title="代理机制"
                    data-url="http://localhost:5001/2017/02/26/Proxy/"
                    data-images="http://localhost:5001/img/2017-02-01-binder/pic.jpeg"
                    data-content="代理

最近想学习插件机制和Hook原理,决定从droidPlugin开始。以下资料多来自weishu与IBM资料,附带一些自己的理解,希望可以共同学习。... | Lizz0y's Notes " >
                    <div class="ds-share-inline">
                      <ul  class="ds-share-icons-16">
                        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                        <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                        <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                        <li><a class="ds-douban flat" href="javascript:void(0);" data-service="douban">豆瓣</a></li>
                      </ul>
                      <div class="ds-share-icons-more">
                      </div>
                    </div>
                <hr>
                </div>
                <!-- 多说 Share end-->
                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/02/01/binder/" data-toggle="tooltip" data-placement="top" title="Binder系列">&larr; Previous Post</a>
                    </li>
                    
                    
                </ul>


                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                        data-thread-key="/2017/02/26/Proxy"
                        data-title="代理机制"
                        data-url="http://localhost:5001/2017/02/26/Proxy/" >
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                

                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User by Hux
    var _user = 'lizz0y';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user };
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    


                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Liz Notes 2017
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-49627206-1';
    var _gaDomain = 'huangxuan.me';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '4cc1f2d8f3067386cc5cdb626a202900';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
