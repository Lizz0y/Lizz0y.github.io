---
layout:     post
title:      "存储管理(一)"
date:       2017-03-12
author:     "Liz"
header-img: "img/2017-02-01-binder/pic.jpeg"
tags:
    - Linux
    - SourceCode
    - Memory
---

从这篇开始`linux`分析之旅,每周70页,看的是毛的书,但还是强推
![](/img/2017-03-12-linux-memory-1/14892981842773.jpg)

里面的图总结的非常精彩,共勉。

#### 具体映射过程:

`i386 cpu`使用代码段寄存器CS来作为段式映射的段选择码,根据`CS`的`bit2`来选择`GDT`还是`LDT`作为段描述表,但其实在`linux`中,每个段的基址都是0,所以虚地址到线性地址的映射保持不变,即:段映射屁用也没有。

页式映射:
![](/img/2017-03-12-linux-memory-1/14892888189387.jpg)
![](/img/2017-03-12-linux-memory-1/14892922877772.jpg)


系统空间在物理内存是从最低的地址开始,而在虚存空间占据最高的1G字节,因此对于内核而言,内存映射是简单的线性映射,`0xC000000`就是偏移量,即:
虚拟地址 = 实际地址 + `0xc000000`

##### pte_entry

pte在32位系统上长4个字节,但是作为指针他只有高20位有用。同时,所有物理页面都是4K字节边界对齐,所以PTE**作为指针**低12位一定是0,但全写0真是浪费空间,所以低12位linux将其用于页面的状态信息与访问权限。

定义`pgprot_t`与低12位对应

内核中有一个`mem_map`的全局量,指向`page`数据结构,`page`即物理页面,因此`mem_map`就是全局物理页面的集合。而`pte`的指针部分就是该集合中的`index`

#### zone

![](/img/2017-03-12-linux-memory-1/14892932710944.jpg)

传统`CPU`的整个物理空间都是均匀一致的,`cpu`访问任何一个地址的时间都相同，称为`UMA`。但在`NUMA`中，为非均质存储结构,对某个特定的`CPU`访问自己模块的存储器速度是最快的。


在`UMA`结构中,仓库中的物理页面会被划分为多个管理区(其实就三个,`ZONE_DMA`,`ZONE_HIGHMEM`,`ZONE_NORMAL`)为了以后分配内存方便,在管理区结构中会有一个队列来保存一些连续的物理页面,连续长度为2,4,8,16...

在`NUMA`结构中,引入新的代表存储节点的`pglist_data`即`pg_data_t`结构,具体层次如下图:

![](/img/2017-03-12-linux-memory-1/14892968057308.jpg)

![](/img/2017-03-12-linux-memory-1/14892932354465.jpg)


[`http://lxr.free-electrons.com/source/include/linux/mmzone.h?v=2.4.37#L32`](linux source code在线阅读)

觉得这个网址很好看,以后打算linux源码都直接截图分析了。

![](/img/2017-03-12-linux-memory-1/14892970550078.jpg)

`node_zonelists`代表该节点的分配策略,在分配页面时会进行策略指定。


#### vm_area_struct

一个很重要的虚存结构,代表离散的虚存区间,大名鼎鼎的`vma`
![](/img/2017-03-12-linux-memory-1/14892973217245.jpg)


* `vm_start` 起始地址
* `vm_end` 结束地址
* `vm_rb` 红黑树节点,增加搜索速度
* `vm_mm` 指向`mm_struct`的指针,这是一个虚存最上层的数据结构,代表整个虚拟内存

一个进程只有一个`mm_struct`,但后者可能被多个进程共享,如`vfork()`或`clone()`,子进程可以和父进程共享

#### 页面的生命周期

之前一直对物理页面,盘上页面等概念有些模糊,这里先列一些关键点:

* 页面表项`PTE`为空,代表虚拟内存还没有和**物理地址**建立映射关系
* 当建立映射关系后,如果物理页面在内存中,则`PTE`指向该物理页面,如果不在内存中,说明该物理页面已经被换出到盘上或者文件中,则`PTE`指向一个特殊的代表盘或文件的数据结构
* 盘上一直有物理页面,当虚存需要用到时,会新建一个内存物理页面,然后将盘上的内容写入该内存物理页面。
* 当内存不够时,内存物理页面会重新写回到盘上物理页面,同时销毁自己,但如果不`dirty`，就是说内存物理页面没被进程写过,那不重写也无所谓。

以上都是一些简单的概念,但能防止自己混乱= = 

##### 缺页异常

当虚存要用到物理地址时,发现还没有建立映射或者物理页面不在内存中时,就会发生缺页异常。

首先通过`find_vma`找到**结束地址大于给定地址的**第一个区间。
![](/img/2017-03-12-linux-memory-1/14892992143851.jpg)

![](/img/2017-03-12-linux-memory-1/14892997004993.jpg)

`brk`空洞指上图堆栈与代码之间的大空洞,映射空洞指由于区间销毁或建立映射时跳过了一块地址留下的空洞。

如果是第二种空洞,会发出一个信号,当系统从中断返回时会检查当前进程有无悬而未决的信号,有的话就会进行处理,此场景就会发出`segment fault`的提示。

##### 堆栈扩展

`expand_vm_area(stack)`

再来看上图的第一种空洞,即如果是堆栈不够需要扩展时,大体走以下两步:

* 将前面提到的`vm_area_struct`数据结构的 `start` 扩充一下 栈是从上往下的
* 通过`handle_mm_fault`建立新扩展页面对物理内存的映射

![](/img/2017-03-12-linux-memory-1/14893001768777.jpg)



`pmd`指向的页面表可能不存在,需要先分配:
![](/img/2017-03-12-linux-memory-1/14893004916169.jpg)

通过`handle_pte_fault`对页面进行分配。

![](/img/2017-03-12-linux-memory-1/14893215630252.jpg)

`mk_pte(ZERO_PAGE(addr))`代表映射的物理页面永远是只读的同一个物理内存页面,只有可写的页面才会为其通过`alloc_page()`分配独立的物理内存。

> 当`CPU`从一次页面错异常处理返回用户空间时,会先重新执行中途夭折的命令。但中断和`trap`会执行下一条命令。因此缺页时,会执行夭折的命令。

##### 页面周转

前面说过,如果pte指向的物理页面不在内存中,则指向另一个数据结构:`swap_entry_t`

`swap_info_struct`代表盘或文件

![](/img/2017-03-12-linux-memory-1/14893226222930.jpg)


`offset`代表盘上偏移,`type`其实代表第几个盘。。
![](/img/2017-03-12-linux-memory-1/14893220774979.jpg)


* `lowest_bit,highest_bit`:文件哪部分用于页面交换
* `swap_map`:数组的每一个整数代表盘上的一个物理页面

为了防止页面抖动,页面的周期可分为换出与释放。即不立即释放准备换出的页面,而是将其page结构留在一个不活跃队列中,如果经过一段时间后还没有被访问,则需要最后退役了。

当新创建页面时,会将`page`链入`clean`队列,`active`队列与一些`hash`队列中。

再来看看页面的分配 这是一个艰苦卓绝的过程:
![](/img/2017-03-12-linux-memory-1/14893235460744.jpg)


* `gfp_mask`:分配策略
* `order`:页面大小 `1<<order`

在NUMA结构中,首先通过`NODE_DATA(numa_node_id())`找到距离当前`cpu`最近的`pg_data_t`结构,然后根据策略进行分配。

* 看`zone`中空闲页面大于`watermark`,则可以从`z`中`rmqueue`分配一个页面。
![](/img/2017-03-12-linux-memory-1/14893244789255.jpg)


没有分配成功,则尝试唤醒kswapd内核线程
![](/img/2017-03-12-linux-memory-1/14893248387443.jpg)


还是没有分配成功,降低水位要求,如下图,从`low->min->0`
![](/img/2017-03-12-linux-memory-1/14893250674286.jpg)


通过`balance_classzone`后,再次尝试分配,还不成功就可以GG了。这个`balance_classzone`也不重要,暂且先忽略。(其实是没看懂orz)
![](/img/2017-03-12-linux-memory-1/14893254330209.jpg)


最后分析`rmqueue`,很有意思的一个函数。
![](/img/2017-03-12-linux-memory-1/14893258306356.jpg)


首先,通过`list_entry`取下一个`page`结构,然后将它从队列中删除。这时候取下来的`page`大小一定是≥`order`,所以还要通过`expand`进行弥补。
![](/img/2017-03-12-linux-memory-1/14893260809151.jpg)


在`expand`中,将`page`大小按/2进行缩小,知道与`order`相同。并且缩小的另一半要重新加回到应有的队列中去。
![](/img/2017-03-12-linux-memory-1/14893262932531.jpg)








