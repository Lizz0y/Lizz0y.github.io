---
layout:     post
title:      "深入理解Java虚拟机"
date:       2017-04-11
author:     "Liz"
header-img: "img/2017-02-01-binder/pic.jpeg"
tags:
    - Java
    - 深入理解Java虚拟机
    - 阅读笔记
---

趁着做毕设,决定把基础补一下,很多时候还是不能从原理去分析问题。这篇拖了很久额。。

### 内存管理
![](/img/2017-04-11-java-virtual-machine/14907778671562.jpg)


* 程序计数器: 线程独立维护,线程私有内存
* 虚拟机栈: 即普通认知上的栈,有关方法执行,局部变量空间在编译期间已经分配完成,在运行期间不再变化。
* 本地方法栈:执行native方法
* 堆:被所有线程共享,在虚拟机启动时创建,存放对象实例，即GC堆,可划分多个线程私有的分配缓冲区
* 方法区:所有线程共享,存储已被虚拟机加载的类,常量等数据。看完后面会知道,加载class文件时会把字节流转化为方法区的运行时数据结构,包括运行时的常量池,存放编译期间生成的各种字面量

![](/img/2017-04-11-java-virtual-machine/14907888844092.jpg)


>`intern`
`public String intern()`
返回字符串对象的规范化表示形式。
一个初始时为空的字符串池，它由类 String 私有地维护。
当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。
它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。
所有字面值字符串和字符串赋值常量表达式都是内部的。
返回：
一个字符串，内容与此字符串相同，但它保证来自字符串池中。

由此引出运行时常量池是可以动态变化的

### 对象创建

类加载,为对象在堆中分配内存,将基本信息比如对象的hash,对象的GC Age存放在对象头,然后执行<init>方法 ---- 对象头主要包括两部分:

* 存储对象自身的运行时数据,如hash,GC Age,锁状态标识等等 即Mark Word。
* 类型指针,指向类元数据的指针

实例数据存储对象真正有用的信息,即各种字段内容


![](/img/2017-04-11-java-virtual-machine/14907898658053.jpg)
![](/img/2017-04-11-java-virtual-machine/14907898806548.jpg)



#### class文件

对于一份Java代码,使用编译器可以把代码编译为存储字节码的class文件,该字节码文件可以使用Java虚拟机执行。要注意,任何一个class文件只对应唯一一个类或接口的定义信息！

class文件的具体格式就不赘述,class中最大的区域即为常量池。常量池主要存放两种内容:字面量和符号引用。字面量主要为字符串,声明为final的常量值等,
在常量池中会存放符号引用,符号引用有以下三种:

* 类和接口的全限定名
* 字段的名称和描述符
* 方法的名称和描述符

符号引用很值得关注,java不会在编译时就确定各种方法和字段的内存布局信息,而是在运行时动态解析,翻译到具体的内存地址,所以虚拟机在加载class文件时,需要从常量池获得对应的符号引用，再在类创建或运行时解析,翻译到具体的内存地址之中。具体的符号引用有见下图,或许可以提供一些启发:

![](/img/2017-04-11-java-virtual-machine/14907789912805.jpg)
使用Javap可以输出常量表




>符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。





### 虚拟机类加载

与编译时需要进行连接的语言不同,Java类型的加载连接和初始化都是在程序运行期间完成的。

![](/img/2017-04-11-java-virtual-machine/14899303847175.jpg)
上图不是在编译,而是在运行时动态进行的。
     
     
#### 加载时机

* 遇到`new` `getstatic` `putstatic` `invokestatic`
* 反射
* 初始化子类时会去加载父类
...

注意:

1. 对于被final修饰的静态字段,在编译时已经把结果放入了常量池,所以是不会引起类的初始化的。
2. 通过子类引用父类的静态字段,只会触发父类的初始化

#### 加载

在类加载阶段,完成3件事情:
1) 通过类的名字获取类的二进制字节流
2) 将字节流转化为方法区的运行时数据结构
3) 在内存中生成java.lang.Class对象,该对象代表这个class,存储在方法区中

#### 准备


在准备阶段,为类变量分配内存,设置初始值,在这时只分配static修饰的变量,将其赋予**初始值**,实例变量会在对象实例化时随对象一起分配在Java堆中。对于final类型的会直接赋予值,因为该类型的已经在编译时写入class文件了。其余为**初始值**即零值

#### 解析

符号引用在class文件中以`CONSTANT_Class_info`,`CONSTANT_Fieldref_info`等类型的常量出现,解析阶段将符号引用替换为直接引用。

符号引用与虚拟机实现的内存布局无关,但直接引用可以定位到目标。引用的目标必然已经存在于内存中。

#### 初始化

初始化阶段执行类构造器`<clinit>`,即所有类变量的赋值动作和静态语句块
`<clinit>`父类肯定优先于子类,如果多个线程同时初始化一个类,不要在`<clinit>`方法中执行耗时操作,因为会被阻塞。


### 类加载器
类加载器实现类的加载(好像废话),比较两个类是否相等,特别要注意看是否由同一个类加载器加载。

#### 双亲委派模式

类加载器可以分为三种:

* 启动类加载器:`bootstrap classloader`:加载`<JAVA_HOME>\lib`目录中的,并且名字需要被虚拟机识别
* 扩展类加载器:`extClassLoader`:加载`lib\ext`目录
* 应用程序类加载器,加载用户类路径的类。

![](/img/2017-04-11-java-virtual-machine/14898494026944.jpg)

上图是众人皆知的双亲委派模式,如果一个类加载器收到类加载的请求,会先把请求委派给父类加载器,如果无法加载再由自己加载,可以解决用户自己写系统重类想要替代系统类的不安全行为。

##### loadClass() vs findClass()
`findClass()`是遵守双亲委派模式,而`loadClass()`是不遵守的。
在`Extension ClassLoader`使用的是`findClass()`,`AppClassLoader`使用的是`loadClass()`

>`Launcher$AppClassLoader`是用于加载各个不同应用下面的类，同一个JVM中可以同时存在多个应用，而这些应用可能是来自不同的开发方，他们之间彼此可能都不知道是谁，但是他们写的类却可能具有相同的全限定名，所以为了确保这些应用之间互不干扰，就需要由各应用的类加载器去加载所属应用的类，这样就不会发生类冲突了。

因为实际上,双亲委派模式是先看类是否被加载过,再看父节点是否可以加载！

所以我们在写应用时,为了遵守双亲委派模式,重写findClass()即可,在父节点加载失败时,会自动调用自己的`findClass()`,不需要重写`loadClass()`

但是`loadClass()`在有的时候也是有用的:

![](/img/2017-04-11-java-virtual-machine/14918904833776.jpg)
如果要想在JVM的不同类加载器中保留具有相同全限定名的类，那就要通过重写`loadClass`来实现，此时首先是通过用户自定义的类加载器来判断该类是否可加载，如果可以加载就由自定义的类加载器进行加载，如果不能够加载才交给父类加载器去加载。




### 运行时

#### java栈帧结构

![](/img/2017-04-11-java-virtual-machine/14898498688630.jpg)

#### 方法调用

在前面类加载时,会把符号引用转化为直接引用,这些引用称为静态解析。即方法在程序真正运行之前就有一个可确定的调用版本,并且在运行期间不可变。主要有静态方法和私有方法。

#### 分派

##### 重载

首先看一段解释:

![](/img/2017-04-11-java-virtual-machine/14899038259031.jpg)
编译器在编译时根据参数的静态类型决定使用哪个重载(overload)版本

##### 重写(override)

即动态分发,编译时根据调用者静态类型与参数的静态类型选择方法,然后运行时先查找实际类型是否有相同函数签名的方法,找不到再依次向上在父类中寻找。

##### 方法选择总结

在编译器编译过程,使用静态分配。根据静态类型与方法参数选择符号引用
在运行阶段,使用动态分配,根据方法接受者的实际类型来选择实际方法。

### 编译优化

一开始总是与编译成字节码弄混,其实java代码会在编译器前端被先编译成字节码（javac）即class文件,然后jvm会在编译器后端把字节码变成机器码

这部分说深了就比较复杂,涉及较多编译原理的知识,简单总结一下:

编译过程主要分为三个过程:

* 解析与填充符号表
* 插入式注解处理器的注解处理过程
* 分析与字节码生成过程

该过程更像是编译原理的过程,通过词法和语法分析,将字符流转化为语法树,树的每一个节点都代表一个语法结构,例如包,类型,修饰符,运算符等结构。根据语法树填充符号表。

然后进行语义分析,标注检查变量使用前是否被声明,变量与赋值之间的数据类型是否匹配。同时检查数据及控制流,分析方法的每条路径是否都有返回值等

> 有个很好玩的例子:
> 在参数中赋予final对运行期间是没有作用的,因为局部变量在常量池中没有访问标记,所以final只会在编译性间作不变性的保障。


最后解语法糖,生成字节码。生成字节码的过程中,语法树中加入了`<init>`与`<clinit>`方法。

#### 语法糖🍬

##### 泛型

Java中,泛型只在程序源码中存在,编译后的字节码文件中已经替换完原生类型,并且在相应的地方插入了强制转型,所以泛型在Java中只能算是一颗语法糖。

所以在重载中,只改变泛型类型是不能被编译通过的,(解释了我多年的困惑,在jdk1.6后引入Signature属性,可以存储一个方法在字节码层面的特征签名,即保存参数化类型的信息。因此我们还是可以通过反射获取参数化类型。

##### 自动装箱&拆箱的陷阱

在比较对象与基本类型时,对象会进行拆箱。拆箱即为intValue()操作,特别注意不能为null

```java
Integer i1=100;  
Integer i2=100;  
Integer i3=300;  
Integer i4=300;  
System.out.println(i1==i2); //true
System.out.println(i3==i4); //false
```
装箱为`valueOf()`:
```java
 public static Integer valueOf(int i) {  
        if(i >= -128 && i <= IntegerCache.high)  
            return IntegerCache.cache[i + 128];  
        else  
            return new Integer(i);  
    }  
```
所以对于-128至127,是同一个Integer对象

>当封装类与基础类型进行\==运行时，封装类会进行拆箱，拆箱结果与基础类型对比值；而两个封装类进行\==运行时，与其它的对象进行\==运行一样，对比两个对象的地址，也即判断是否两个引用是否指向同一个对象。


### 运行优化

这部分涉及的更复杂了,即编译的后端。先记录简单知识,以HotSpot为例,主要是解析器和即时编译器共存的架构。

解析器:解析器可以省去编译(后端)的时间,立即执行,即翻译一条执行一条

编译器:编译器可以把代码编译成本地代码,执行效率高,注意这里和前面的编译优化的区别,这里是把class文件编译为机器语言。

![](/img/2017-04-11-java-virtual-machine/14899989334824.jpg)
看我机子上的mixMode,代表就是解析器和编译器共存的模式。

HotSpot有两个即时编译器,即C1和C2

热点代码:当JVM发现某个方法或代码运行特别频繁，会把它们当做热点代码,为了提高执行效率,会在运行时把代码编译成机器码

分层编译:

![](/img/2017-04-11-java-virtual-machine/14901125422645.jpg)


看了一些知乎的回答觉得非常帮助我理解:


![](/img/2017-04-11-java-virtual-machine/14901135496721.jpg)
![](/img/2017-04-11-java-virtual-machine/14901137838955.jpg)

![](/img/2017-04-11-java-virtual-machine/14901138639999.jpg)

### 并发与线程安全

局部变量和方法参数是线程私有的,不会被共享与竞争

JAVA内存模型:
所有变量都存储在主内存,每个线程有自己的工作内存,保存了该线程所使用的变量的主内存副本拷贝

![](/img/2017-04-11-java-virtual-machine/14901142686746.jpg)
Java内存模型共定义了8种原子性操作:
lock(主线程),`unlock,read,load,use,assign,store,write`

注意:lock作用于主内存的变量,把变量标识为一个线程独占的状态。一个变量只允许一条线程对其lock,lock后会清空工作内存中此变量的值,之后使用一定会重新执行load或assign,对一个变量unlock之前,必须先把此变量同步回主内存

#### volatile

volatile的使用看两个例子就行:

1. `count++`
2. `while(a)  first a = true ;  then another thread change a to false`

在不符合以下两条规则的运算场景中,依旧要加锁保持原子性:

* 运算结果并不依赖变量的当前值,或者确保只有单一的线程修改
* 变量不需要与其他的状态变量共同参与不变约束


使用`volatile`还可以禁止指令重排序优化

##### 原子性

##### 可见性

`volatile,synchronized,final`
同步的可见性在于unlock之前会把变量同步回主内存


##### 有序性

`volatile,synchronized`

#### 先行发生原则

![](/img/2017-04-11-java-virtual-machine/14901151886171.jpg)

#### 线程三种方式:

#####内核线程 KLT & 轻量级进程   

需要进行上下文切换,使用纯线程,因此消耗内核资源
![](/img/2017-04-11-java-virtual-machine/14903676128755.jpg)

######用户线程  完全用户态完成 


##### 用户线程+轻量级线程

![](/img/2017-04-11-java-virtual-machine/14903677303678.jpg)
### 线程安全

当多个线程访问一个对象时,如果不用考虑这些线程在运行时环境下的调度和交替执行,也不需要进行额外的同步或其他任何的协调操作

#### 无同步

有两类代码天身线程安全:

* 可重入代码,纯代码:即就算代码被中断,控制权返回时原理的程序不会出现任何错误。
* 线程本地存储

#### 锁优化

##### 自适应自旋

我们知道自旋锁会一直等待,如果等待时间少则是很高效率因为不用上下文切换了,但是时间长就白白消耗处理器资源。jdk1.6后加入自适应自旋锁,即自旋时间不再固定,而是由前一次在同一个锁上的自旋时间与状态来决定。

##### 锁消除

JIT在运行时如果发现不可能存在共享数据竞争则把锁解除

##### 锁粗化

一系列连续操作对同一个对象反复加锁和解锁,就把加锁同步的范围粗化

##### 轻量级锁

使用CAS进行同步,基于对于绝大部分的锁不存在竞争的依据。如果发生竞争,则比使用传统锁要耗时,多了CAS这一步。

##### 偏向锁

基于轻量级锁,偏向于某个线程。一旦出现多线程竞争的情况就必须撤销偏向锁。如果程序中大多数的锁总是被同一个线程访问,适合用偏向锁。
 




